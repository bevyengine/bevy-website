{% extends "layouts/base.html" %}

{% block content %}
<div class="example">
    <div class="example__header">
        {% set total_ancestors = page.ancestors | length %}
        {% set parent_idx = total_ancestors - 1 %}
        {% set category = get_section(path=page.ancestors | nth(n=parent_idx)) %}
        <h2 class="example__title">{{ category.title }} / {{ page.title }}</h2>
        <a class="example__back" href="/examples"><i class="icon icon--chevron-left"></i> Back to examples</a>
        <a class="example__github" href="https://github.com/bevyengine/bevy/blob/latest/examples/{{ page.components[1] }}/{{ page.title }}.rs">
            <i class="icon icon--github"></i> View in GitHub
        </a>
    </div>
    <div class="example__canvas-wrapper">
        <div class="example__progress-status" data-progress-status></div>
        <canvas class="example__canvas example__canvas--loading" id="bevy" width="1280" height="720"></canvas>
    </div>
    <div class="example__code media-content">
        {% set code = load_data(path="content/examples/" ~ page.components[1] ~ "/" ~ page.title ~ "/" ~ page.title ~ ".rs") %}
        {% set data = "```rust
" ~ code ~ "```" %}

        {{data | markdown(inline=true) | safe}}
    </div>
</div>
<script type="module">
    // Hi curious user!
    // This approach to add loading feedback on web is a big HACK. Please review `generate_wasm_examples.sh`
    // to see the patches we're applying to the JS file to accept a custom `fetch`. This is a temporary
    // workaround until Bevy has an in-engine mode for showing loading feeback. See:
    // https://github.com/bevyengine/bevy-website/pull/355
    // https://github.com/bevyengine/bevy-website/issues/338
    // https://github.com/bevyengine/bevy-website/issues/236
    import { ReadableStream as PolyfillReadableStream, TransformStream as PolyfillTransformStream } from '/web-streams.es6.mjs';
    import { createReadableStreamWrapper } from '/web-streams-adapter.mjs';
    import init from './{{ page.title }}.js';

    // Streams API converters (from/to polyfill)
    const toPolyfillReadable = createReadableStreamWrapper(PolyfillReadableStream);
    const toNativeReadable = createReadableStreamWrapper(window.ReadableStream);

    // Elements
    const canvasEl = document.getElementById('bevy');
    const progressStatusEl = document.querySelector('[data-progress-status]');
    let hideProgressTimeoutId;

    // Custom fetch that tracks assets loading progress
    async function trackLoadingProgressFetch(resource) {
        const response = await fetch(resource);
        const lengthBytes = response.headers.get('content-length');
        let loadedBytes = 0;

        // Create new progress bar
        const trackEl = document.createElement('div');
        trackEl.classList.add('example__progress-track');

        const progressBarEl = document.createElement('div');
        progressBarEl.classList.add('example__progress-bar');

        // Attach progress bar
        trackEl.appendChild(progressBarEl);
        progressStatusEl.appendChild(trackEl);

        // Pipe download through a `TransformStream`
        const transform = new PolyfillTransformStream({
            start() {
                progressStatusEl.style.display = 'block';

                if (hideProgressTimeoutId) {
                    clearTimeout(hideProgressTimeoutId);
                }
            },
            transform(chunk, controller) {
                loadedBytes += chunk.byteLength;

                // Update progress bar
                const percent = loadedBytes / lengthBytes;
                progressBarEl.style.width = (percent * 100) + '%';

                // Simply pass through the data without touching it.
                controller.enqueue(chunk);
            },
            flush() {
                // Download done, hide progress status element
                hideProgressTimeoutId = setTimeout(() => {
                    progressStatusEl.style.display = 'none';
                }, 50);
            },
        });

        // Give the caller a new version of the Response where we pass its
        // ReadableStream through the TransformStream.
        //
        // Convert to `toPolyfillReadable` to be able to use `pipeThrough` and then
        // back to `toNativeReadable` (`ReadableStream`) so that everything keeps working
        return new Response(toNativeReadable(toPolyfillReadable(response.body).pipeThrough(transform)), response);
    };

    // Init wasm example, pass custom `fetch` implementation
    init(trackLoadingProgressFetch);
</script>
{% endblock content %}
